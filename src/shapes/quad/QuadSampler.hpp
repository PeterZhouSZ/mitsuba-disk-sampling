/*
 * DiskSampler.hpp
 *
 *      Author: ibon
 */

#ifndef __QUADSAMPLER_HPP__
#define __QUADSAMPLER_HPP__

#include <limits>

#include "vector3.hpp"
namespace {
	using v3l::vector3;
}

#include "mathUtil.hpp"

template<class T>
class QuadSampler;

template<class T>
class QuadSamplingRecord
{
	friend class QuadSampler<T>;
private:
	// Quad coordinate system
	vector3<T> o, x, y, z;
	// Rectangle local coordinates
	T x0, x1;
	T y0, y0sq, y1, y1sq;
	T z0, z0sq;
	// Precomputed constants
	T b0, b1, b0sq, k;
	// Spherical quad area
	T S, invS;
private:
	// Constants
	static constexpr T eps = T(std::numeric_limits<T>::epsilon());
public:
	QuadSamplingRecord() {};
	/*
	 * A point over the unit sphere corresponding to the mapping from the [0..1]^2
	 * square to the quad projected solid angle
	 * 		u   : x coordinate over the [0..1]^2 square
	 * 		v   : y coordinate over the [0..1]^2 square
	 * 		pdf : probability of the sample
	 */
	vector3<T> sample(const T u, const T v, T& pdf) const;
	/*
	 * pdf corresponding to the quad sample as generated by this method
	 */
	T samplePdf(const vector3<T> p) const;
};

template<class T> inline
vector3<T> QuadSamplingRecord<T>::sample(const T u, const T v, T& pdf) const
{
	// Compute cu
	T au = u * this->S + this->k;
	T fu = (std::cos(au) * this->b0 - this->b1) / std::sin(au);

	T cu = 1 / std::sqrt(fu*fu + this->b0sq) * sml::sign(fu);
	cu = sml::clamp(cu, T(-1), T(1)); // avoid NaNs

	// Compute xu
	T xu = -(cu * this->z0) / std::sqrt(T(1) - cu*cu);
	xu = sml::clamp(xu, this->x0, this->x1); // avoid Infs

	// Compute yv
	T d = std::sqrt(xu*xu + this->z0sq);
	T h0 = this->y0 / std::sqrt(d*d + this->y0sq);
	T h1 = this->y1 / std::sqrt(d*d + this->y1sq);
	T hv = h0 + v * (h1 - h0);
	T hv2 = hv*hv;

	T yv = (hv2 < (T(1) - eps)) ? (hv * d) / std::sqrt(T(1) - hv2) : this->y1;

	// Probability is inverse of spherical area
	pdf = this->invS;

	// Transform (xu, yv, z0) to world coords
	return (this->o + xu * this->x + yv * this->y + this->z0 * this->z);
}

template<class T> inline
T QuadSamplingRecord<T>::samplePdf(const vector3<T> p) const
{
	return this->invS;
}

// -----------------------------------------------------------------------------

template<class T>
class QuadSampler
{
private:
	// Constants
	static constexpr T two_pi = T(2.0*3.14159265358979323846);
public:
	QuadSampler() {}

	/*
	 * Disk sampling record
	 * 		o  : shading point
	 * 		s  : quad lower corner
	 * 		ex : quad x axis
	 * 		ey : quad y axis
	 */
	QuadSamplingRecord<T> createRecord(const vector3<T>& o, const vector3<T>& s,
			const vector3<T>& ex, const vector3<T>& ey) const;
};

template<class T> inline
QuadSamplingRecord<T> QuadSampler<T>::createRecord(const vector3<T>& o, const vector3<T>& s,
		const vector3<T>& ex, const vector3<T>& ey) const
{
	QuadSamplingRecord<T> quad;

	T exl = v3l::length(ex), eyl = v3l::length(ey);

	// Compute local reference system
	quad.o = o;
	quad.x = ex / exl;
	quad.y = ey / eyl;
	quad.z = v3l::cross(quad.x, quad.y);

	// Compute rectangle coords in local reference system
	vector3<T> d = s - o;
	quad.z0 = v3l::dot(d, quad.z);

	// Flip z to make it point against the rectangle
	if (quad.z0 > T(0)) {
		quad.z = -quad.z;
		quad.z0 = -quad.z0;
	}

	// Store local rectangle coords
	quad.z0sq = quad.z0 * quad.z0;
	quad.x0 = v3l::dot(d, quad.x);
	quad.y0 = v3l::dot(d, quad.y);
	quad.x1 = quad.x0 + exl;
	quad.y1 = quad.y0 + eyl;
	quad.y0sq = quad.y0 * quad.y0;
	quad.y1sq = quad.y1 * quad.y1;

	// Create vectors to four vertices
	vector3<T> v00 = vector3<T>(quad.x0, quad.y0, quad.z0);
	vector3<T> v01 = vector3<T>(quad.x0, quad.y1, quad.z0);
	vector3<T> v10 = vector3<T>(quad.x1, quad.y0, quad.z0);
	vector3<T> v11 = vector3<T>(quad.x1, quad.y1, quad.z0);

	// Compute normals to edges
	vector3<T> n0 = v3l::normalize(cross(v00, v10));
	vector3<T> n1 = v3l::normalize(cross(v10, v11));
	vector3<T> n2 = v3l::normalize(cross(v11, v01));
	vector3<T> n3 = v3l::normalize(cross(v01, v00));

	// Compute internal angles
	T g0 = std::acos(-v3l::dot(n0, n1));
	T g1 = std::acos(-v3l::dot(n1, n2));
	T g2 = std::acos(-v3l::dot(n2, n3));
	T g3 = std::acos(-v3l::dot(n3, n0));

	// Compute predefined constants
	quad.b0 = n0.z;
	quad.b1 = n2.z;
	quad.b0sq = quad.b0 * quad.b0;
	quad.k = two_pi - g2 - g3;

	// Compute solid angle from internal angles
	quad.S = g0 + g1 - quad.k;
	quad.invS = T(1)/quad.S;

	return quad;
}

#endif // __QUADSAMPLER_HPP__
