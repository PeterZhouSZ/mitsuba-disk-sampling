/*
 * DiskSampler.hpp
 *
 *      Author: ibon
 */

#ifndef __DISKSAMPLER_HPP__
#define __DISKSAMPLER_HPP__

#include <iostream>
#include <fstream>

#define BOOST_MATH_MAX_SERIES_ITERATION_POLICY 500
#include <boost/math/special_functions/ellint_3.hpp>
namespace {
	using boost::math::ellint_3;
}
#include <boost/math/special_functions/ellint_1.hpp>
namespace {
	using boost::math::ellint_1;
}

#include "vector3.hpp"
namespace {
	using v3l::vector3;
}
#include "SphericalEllipseSampler.hpp"

template<class T>
class DiskSampler;

template<class T>
class DiskSamplingRecord
{
	friend class DiskSampler<T>;
private:
	// Type of sampling
	SphericalEllipseSampler<T> algorithm;
	// Disk coordinate system
	vector3<T> o, xd, yd, zd;
	// Distance to disk plane from shading point
	T d;
	// Reprojection constants
	T yhp_norm, dhp_norm;
public:
	DiskSamplingRecord() {};
	/*
	 * A point over the unit sphere corresponding to the mapping from the [0..1]^2
	 * square to the disk projected solid angle
	 * 		u   : x coordinate over the [0..1]^2 square
	 * 		v   : y coordinate over the [0..1]^2 square
	 * 		pdf : probability of the sample
	 */
	vector3<T> sample(const T e1, const T e2, T& pdf) const;
	/*
	 * pdf corresponding to the disk sample as generated by this method
	 */
	T samplePdf(const vector3<T>& p) const;
};

template<class T> inline
vector3<T> DiskSamplingRecord<T>::sample(const T e1, const T e2, T& pdf) const
{
	// Generate sample in local coords of the spherical ellipse
	vector3<T> local = this->algorithm.sample(e1, e2, pdf);

	// Don't reproject discarded samples
	if (pdf == -1.0f) {
		return vector3<T>(0.0f);
	}

	T xu = local.x, yu = local.y, zu = local.z;

	// Disk's local coords over the sphere
	T yu_p =  yu * this->dhp_norm + zu * this->yhp_norm;
	T zu_p = -yu * this->yhp_norm + zu * this->dhp_norm;

	T prop = this->d / zu_p;

	// Disk's local coords projected on the disk
	T x = xu   * prop;
	T y = yu_p * prop;
	T z = this->d;

	// Global coords over the disk
	return this->o + x*this->xd + y*this->yd + z*this->zd;
}

template<class T> inline
T DiskSamplingRecord<T>::samplePdf(const vector3<T>& p) const
{
	return this->algorithm.samplePdf(p);
}

// -----------------------------------------------------------------------------

template<class T>
class DiskSampler
{
private:
	// Type of sampling
	typename SphericalEllipseSampler<T>::Type algorithm;

	// Tabulated CDF
	double* CDF;
private:
	// Constants
	static constexpr T pi   = T(3.14159265358979323846);
	static constexpr T pi_2 = T(3.14159265358979323846/2.0);
	static constexpr T eps  = T(1e-5);
public:
	DiskSampler() {}

	DiskSampler(const typename SphericalEllipseSampler<T>::Type algo):
		algorithm(algo), CDF(nullptr)
	{
		// Load CDF data
		this->CDF = (double *)&CDF_hex_data;
	}

	/*
	 * Disk sampling record
	 * 		o  : shading point
	 * 		c  : disk center
	 * 		nd : disk normal
	 * 		r  : disk radius
	 */
	DiskSamplingRecord<T> createRecord(const vector3<T>& o,
			const vector3<T>& cd, const vector3<T>& nd, T r) const;
};

template<class T> inline
DiskSamplingRecord<T> DiskSampler<T>::createRecord(const vector3<T>& o,
		const vector3<T>& cd, const vector3<T>& nd, T r) const
{
	DiskSamplingRecord<T> record;

	// Radius nearly zero
	if (r < eps) {
		record.algorithm.type = SphericalEllipseSampler<T>::Type::ZERO;
		return record;
	}

	vector3<T> l = cd - o;

	// Distance from shading point to disk plane
	T d = -v3l::dot(l, nd);

	// Check if the disk normal is pointing to the opposite side
	// and calculate disk's coordinates Z axis
	if (d < T(0)) {
		record.zd = nd;
		d = -d;
	} else {
		record.zd = -nd;
	}
	record.d = d;

	// Point inside disk plane
	if (d < eps) {
		record.algorithm.type = SphericalEllipseSampler<T>::Type::ZERO;
		return record;
	}

	// Build reference system
	record.xd = cross(l, record.zd);
	if (length2(record.xd) < eps) {
		T x = record.zd.x, y = record.zd.y, z = record.zd.z;

		if (std::abs(x) > std::abs(z)) {
			T invLength = 1.0f / std::sqrt(x*x + y*y);
			record.xd = vector3<T>(-y*invLength, x*invLength, 0.0f);
		} else {
			T invLength = 1.0f / std::sqrt(y*y + z*z);
			record.xd = vector3<T>(0.0f, -z*invLength, y*invLength);
		}
	} else {
		record.xd = normalize(record.xd);
	}
	record.yd = cross(record.zd, record.xd);

	// Store local coordinate system origin
	record.o = o;

	// Shading point projected in disk plane
	vector3<T> o_p = o + d*(record.zd);


	// Distance from projection to disk center
	T h = v3l::length(cd - o_p);

	// Minor axis y coordinates in the disk
	T y0 = h - r;
	T y1 = h + r;

	T inv_sqrt0 = 1.0f / std::sqrt(d*d + y0*y0);
	T inv_sqrt1 = 1.0f / std::sqrt(d*d + y1*y1);

	// Minor axis y coordinates projected in the sphere
	T y0_p = y0 * inv_sqrt0;
	T y1_p = y1 * inv_sqrt1;

	// Minor axis z coordinates projected in the sphere
	T d0_p = d * inv_sqrt0;
	T d1_p = d * inv_sqrt1;

	// Spherical ellipse center coordinates
	T yh_p = (y0_p + y1_p) / 2.0f;
	T dh_p = (d0_p + d1_p) / 2.0f;

	// SE center projected in the disk
	T yh = (d * yh_p) / dh_p;

	// Disk cord length at SE center projection
	T r_p = std::sqrt(r*r - std::pow(h - yh, 2));

	// Mayor axis x coordinates
//	T x0 = -r_p;
	T x1 = r_p;

	// Mayor axis x coordinates projected in the sphere
//	T x0_p = x0 / std::sqrt(x0*x0 + yh*yh + d*d);
	T x1_p = x1 / std::sqrt(x1*x1 + yh*yh + d*d);

	// Spherical ellipse axis
	// Calculations in double precision to avoid numerical instabilities
	double a = double(x1_p);
	double b = double(std::sqrt(std::pow(y1_p - y0_p, 2) + std::pow(d1_p - d0_p, 2)) / 2.0);

	// Discard very small ellipses
	// Possibly unnecessary when working with the tabulated variant
	if (a < eps || b < eps) {
		record.algorithm.type = SphericalEllipseSampler<T>::Type::ZERO;
		return record;
	}

	SphericalEllipseSampler<T> algo;
	switch(this->algorithm) {
		case SphericalEllipseSampler<T>::Type::POLAR :
		case SphericalEllipseSampler<T>::Type::CONCENTRIC :
		{
			double c = (b*(1.0 - a*a)) / (a * std::sqrt(1.0 - b*b));
			double k = std::sqrt((a*a - b*b) / (1.0 - b*b));
			double n = (a*a - b*b) / (a*a*(1.0 - b*b));

			double S = pi_2 - c * ellint_3(k, n, pi_2);

			T asqrtb = a * std::sqrt(1.0f - b*b);
			T bsqrta = b * std::sqrt(1.0f - a*a);
			T phi_coeff = (b*std::sqrt(1.0f - a*a)) / (a*std::sqrt(1.0f - b*b));
			T t_coeff = 1.0f / phi_coeff;

			algo.type = this->algorithm;
			// Spherical ellipse axis
			algo.a = a;
			algo.b = b;
			// Elliptic integral constants
			algo.data.boothData.c = T(c);
			algo.data.boothData.n = T(n);
			algo.data.boothData.k = T(k);
			// Precalc. constants
			algo.data.boothData.phi_coeff = T(phi_coeff);
			algo.data.boothData.t_coeff = T(t_coeff);
			algo.data.boothData.asqrtb = T(asqrtb);
			algo.data.boothData.bsqrta = T(bsqrta);
			// Precalc quadrant area
			algo.data.boothData.S = S;
		}
		break;
		case SphericalEllipseSampler<T>::Type::POLARTAB :
		case SphericalEllipseSampler<T>::Type::CONCENTRICTAB :
		{
			// Find row of the precalc. CDF corresponding to the current arc proportion
			// TODO: Tabulate by (b/a) intervals instead of (beta/alpha) ones
			double alpha = std::asin(a), beta = std::asin(b);

			size_t index = size_t(std::floor(CDF_SIZE * (beta/alpha))) * CDF_SIZE;
			double* CDF1D = &this->CDF[index];

			double c = (b*(1.0 - a*a)) / (a * std::sqrt(1.0 - b*b));
			double k = std::sqrt((a*a - b*b) / (1.0 - b*b));
			double n = (a*a - b*b) / (a*a*(1.0 - b*b));

			double S = pi_2 - c * ellint_3(k, n, pi_2);

			algo.type = this->algorithm;
			// Spherical ellipse axis
			algo.a = a;
			algo.b = b;
			// 1D CDF for fast table inversion
			algo.data.boothTabData.CDF1D = CDF1D;
			// Precalc quadrant area
			algo.data.boothTabData.S = S;
		}
		break;
		case SphericalEllipseSampler<T>::Type::CYLINDRICAL :
		{
			T a_p = a / std::sqrt(1.0f - a*a);
			T b_p = b / std::sqrt(1.0f - b*b);

			T alpha = std::asin(a);
			T beta  = std::asin(b);

			T p  = 1.0f / (b_p * b_p);
			T m  = (a_p * a_p - b_p * b_p)/(a_p * a_p + 1);
			T k  = std::sqrt(m);
			T n  = -b_p * b_p;
			T c1 = (2.0f * a_p) / std::sqrt(1.0f + a_p * a_p);

			T S_2 = c1 * b_p * (p * ellint_1(k, -pi_2) - (p + 1.0f) * ellint_3(k, n, -pi_2));

			algo.type = this->algorithm;
			// Spherical ellipse axis
			algo.a = a;
			algo.b = b;
			// Spherical ellipse arcs
			algo.data.urenaData.alpha = alpha;
			algo.data.urenaData.beta = beta;
			// Tangent ellipse params
			algo.data.urenaData.a_p = a_p;
			algo.data.urenaData.b_p = b_p;
			// Elliptic integral constants
			algo.data.urenaData.n = n;
			algo.data.urenaData.k = k;
			algo.data.urenaData.m = m;
			// Precalc. constants
			algo.data.urenaData.p = p;
			algo.data.urenaData.c1 = c1;
			// Precalc. half area
			algo.data.urenaData.S_2 = S_2;
		}
		break;
		case SphericalEllipseSampler<T>::Type::CYLINDRICALTAB :
		{
			// TODO: Some kind of unbiased tabulation scheme for cilindric sampling
		}
		break;
		case SphericalEllipseSampler<T>::Type::ZERO :
		break;
	}
	record.algorithm = algo;

	// Reprojection constants
	T axis_norm = 1.0f / std::sqrt(yh_p*yh_p + dh_p*dh_p);
	record.yhp_norm = yh_p * axis_norm;
	record.dhp_norm = dh_p * axis_norm;

	return record;
}

#endif // __DISKSAMPLER_HPP__
